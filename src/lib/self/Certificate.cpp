// last modified 

#include "Certificate.h"
//#include <unordered_map>
//#include <vector>
#include <iostream>
#include <fstream>
#include <unistd.h>
#include <stdlib.h>
#include <string.h>
//#include <sys/wait.h>
#include <sys/types.h>
#include <signal.h>
#include "../helper/Webpage.h"
#include "../helper/Misc.h"
#include "../helper/Time.h"

using namespace std;


unsigned Certificate::valid_cnt_ = 0;
const unsigned Certificate::local_port_start_ = 1080;

Certificate::Certificate ( Mode mode,
                           const string& url_test,
                           const string& server, 
                           const string& server_port,
                           const string& password,
                           const string& method,
                           const string& local_addr,
                           const string& fast_open,
                           const string& timeout,
                           const string& workers )
    : mode_(mode), url_test_(url_test),
      server_(server), server_port_(server_port), password_(password), method_(method),
      local_addr_(local_addr), fast_open_(fast_open), timeout_(timeout), workers_(workers),
      b_avail_(false), aver_speed_(0), region_("uncheck"),
      p_webpage_test_(nullptr)
{
    // 派生子进程运行 sslocal
    static const string ss_name("sslocal");
    static const string local_port_for_test("1082"); // 将证书另存为 *.json 时才真正分配本地端口。测试时用一个使用几率较小的端口号
    pid_ss_ = fork();
    if (0 == pid_ss_) {
        // 执行类似如下命令，启动 SS 代理程序：
        // sslocal -s "178.62.51.195" -p 20852 -k "r3fChduVgfwo6HlFMN" -b "127.0.0.1" -l 1082 -m "bf-cfb" -t 512
        int no_file = execlp( ss_name.c_str(),
                              ss_name.c_str(),
                              "-s", server_.c_str(),
                              "-p", server_port_.c_str(),
                              "-b", local_addr_.c_str(),
                              "-l", local_port_for_test.c_str(),
                              "-k", password_.c_str(),
                              "-m", method_.c_str(),
                              "-t", timeout_.c_str(),
                              nullptr );
        
        // sslocal 启动失败，结束子进程，同时结束父进程
        if (-1 == no_file) {
            cerr << "ERROR! please make sure sslocal is installed, "
                 << "you can get it from https://github.com/clowwindy/shadowsocks. " << endl;
            kill(getppid(), SIGKILL);
            exit(EXIT_FAILURE);
        }
    } else if (pid_ss_ < 0) {
        cerr << "ERROR! failure to fork child sslocal. " << endl;
        exit(EXIT_FAILURE);
	}

    // 等待 sslocal 启动完成
    sleep(1);

    // 证书各种模式验证时使用的 Webpage 对象
    p_webpage_test_ = new Webpage(url_test_, "", "socks5://" + local_addr_ + ":" + local_port_for_test);

    // 证书有效性检查
    b_avail_ = checkAvailable_();
    if (!b_avail_) {
        return;
    }

    // 更新有效证书数量
    local_port_ = convNumToStr(local_port_start_ + valid_cnt_);
    ++valid_cnt_;

    // 证书各类模式检查
    switch (mode) {
        case available:
            ;
            break;
            
        case avarspeed:
            aver_speed_ = checkAvarSpeed_();
            break;
            
        case region:
            region_ = checkRegion_();
            break;
            
        case all:
            aver_speed_ = checkAvarSpeed_();
            region_ = checkRegion_();
            break;
    }
}

Certificate::~Certificate ()
{
    kill(pid_ss_, SIGKILL);
    delete p_webpage_test_;
}

bool
Certificate::checkAvailable_ (void) const
{
    return(p_webpage_test_->isLoaded());
}

bool
Certificate::isAvailable (void) const
{
    return(b_avail_);
}

bool
Certificate::writeJsonFile_ (const string& filename) const
{
    ofstream ofs(filename, std::ofstream::out | std::ofstream::trunc);
    if (!ofs) {
        cerr << "ERROR! failure to create file " << filename << endl;
        return(false);
    }

    ofs << "{" << endl;
    ofs << "\t" << "\"comment\": \"###########################################################\"," << endl;
    ofs << "\t" << "\"comment\": \"this SS certificate generated by autoshadower, more certificates\"," << endl;
    ofs << "\t" << "\"comment\": \"please see https://github.com/yangyangwithgnu/autoshadower \"," << endl;
    ofs << "\t" << "\"comment\": \"###########################################################\"," << endl;
    ofs << "\t" << "\"server\": \"" << server_ << "\"" << "," << endl;
    ofs << "\t" << "\"server_port\": " << server_port_ << "," << endl;
    ofs << "\t" << "\"password\": \"" << password_ << "\"" << "," << endl;
    ofs << "\t" << "\"local_address\": \"" << local_addr_ << "\"" << "," << endl;
    ofs << "\t" << "\"local_port\": " << local_port_ << "," << endl;
    ofs << "\t" << "\"timeout\": " << timeout_ << "," << endl;
    ofs << "\t" << "\"method\": \"" << method_ << "\"" << "," << endl;
    ofs << "\t" << "\"fast_open\": " << fast_open_ << "," << endl;
    ofs << "\t" << "\"workers\": " << workers_ << endl;
    ofs << "}" << endl;

    ofs.close();

    return(true);
}

bool
Certificate::saveas (const string& path) const
{
    if (!isAvailable()) {
        cerr << "WARN! this SS certificate is unavailable. "
             << "so you can't saveas(). " << endl;
        return(false);
    }

    string cert_file_name = local_port_;

    switch (mode_) {
        case available:
            ;
            break;
            
        case avarspeed:
            cert_file_name += "-[" + convNumToStr((long)(getAvarSpeed() + 0.5)) + "KBs]"; // 四舍五入取整
            break;
            
        case region:
            cert_file_name += "-[" + convNumToStr(getRegion()) + "]";
            break;
            
        case all:
            cert_file_name += "-[" + convNumToStr((long)getAvarSpeed()) + "KBs]";
            cert_file_name += "-[" + convNumToStr(getRegion()) + "]";
            break;
    }

    cert_file_name += ".json";


    return(writeJsonFile_(path + "/" + cert_file_name));
}

string
Certificate::checkRegion_ (void) const
{
    return(p_webpage_test_->checkProxyOutRegionByThirdparty());
}

const string&
Certificate::getRegion (void) const
{
    if (!isAvailable()) {
        cerr << "WARN! this SS certificate is unavailable. "
             << "so you can't getRegion(). " << endl;
        static const string empty_str("");
        return(empty_str);
    }

    return(region_);
}

double
Certificate::checkAvarSpeed_ (void) const
{
    // TODO 跨平台
    static const string tmp_path("/tmp/autoss_speedtest");
    static const string file_for_downspeed_test_url("https://github.com/yangyangwithgnu/autoshadower/raw/master/misc/just_for_speed_test.tar.gz");
    p_webpage_test_->downloadFile( file_for_downspeed_test_url,
                                   tmp_path,
                                   "",
                                   16, // 文件是否下载完整对测试没影响，只要成功启动下载，测速就是准确的
                                   1 );

    const double avar_speed = p_webpage_test_->getAvarSpeedDownload() / 1024; // KB/s

    remove(tmp_path.c_str());

    return(avar_speed);
}

double
Certificate::getAvarSpeed (void) const
{
    if (!isAvailable()) {
        cerr << "WARN! this SS certificate is unavailable. "
             << "so you can't getAvarSpeed(). " << endl;
        return(0);
    }

    return(aver_speed_);
}

